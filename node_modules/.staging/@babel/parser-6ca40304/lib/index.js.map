{"version":3,"file":"index.js","sources":["../src/tokenizer/types.js","../src/util/scopeflags.js","../src/util/whitespace.js","../src/util/location.js","../src/parser/base.js","../src/parser/comments.js","../src/parser/error-message.js","../src/parser/error.js","../src/plugins/estree.js","../src/tokenizer/context.js","../../babel-helper-validator-identifier/src/identifier.js","../../babel-helper-validator-identifier/src/keyword.js","../src/util/identifier.js","../src/plugins/flow.js","../src/plugins/jsx/xhtml.js","../src/plugins/jsx/index.js","../src/util/scope.js","../src/plugins/typescript/scope.js","../src/util/production-parameter.js","../src/plugins/typescript/index.js","../src/plugins/placeholders.js","../src/plugins/v8intrinsic.js","../src/plugin-utils.js","../src/options.js","../src/tokenizer/state.js","../src/tokenizer/index.js","../src/parser/util.js","../src/parser/node.js","../src/parser/lval.js","../src/parser/expression.js","../src/parser/statement.js","../src/util/class-scope.js","../src/parser/index.js","../src/index.js"],"sourcesContent":["// @flow\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n\n// The `startsExpr` property is used to determine whether an expression\n// may be the “argument” subexpression of a `yield` expression or\n// `yield` statement. It is set on all token types that may be at the\n// start of a subexpression.\n\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\n\ntype TokenOptions = {\n  keyword?: string,\n  beforeExpr?: boolean,\n  startsExpr?: boolean,\n  rightAssociative?: boolean,\n  isLoop?: boolean,\n  isAssign?: boolean,\n  prefix?: boolean,\n  postfix?: boolean,\n  binop?: ?number,\n};\n\nexport class TokenType {\n  label: string;\n  keyword: ?string;\n  beforeExpr: boolean;\n  startsExpr: boolean;\n  rightAssociative: boolean;\n  isLoop: boolean;\n  isAssign: boolean;\n  prefix: boolean;\n  postfix: boolean;\n  binop: ?number;\n  updateContext: ?(prevType: TokenType) => void;\n\n  constructor(label: string, conf: TokenOptions = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n}\n\nexport const keywords = new Map<string, TokenType>();\n\nfunction createKeyword(name: string, options: TokenOptions = {}): TokenType {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name: string, binop: number) {\n  return new TokenType(name, { beforeExpr, binop });\n}\n\nexport const types: { [name: string]: TokenType } = {\n  num: new TokenType(\"num\", { startsExpr }),\n  bigint: new TokenType(\"bigint\", { startsExpr }),\n  decimal: new TokenType(\"decimal\", { startsExpr }),\n  regexp: new TokenType(\"regexp\", { startsExpr }),\n  string: new TokenType(\"string\", { startsExpr }),\n  name: new TokenType(\"name\", { startsExpr }),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", { beforeExpr, startsExpr }),\n  bracketHashL: new TokenType(\"#[\", { beforeExpr, startsExpr }),\n  bracketBarL: new TokenType(\"[|\", { beforeExpr, startsExpr }),\n  bracketR: new TokenType(\"]\"),\n  bracketBarR: new TokenType(\"|]\"),\n  braceL: new TokenType(\"{\", { beforeExpr, startsExpr }),\n  braceBarL: new TokenType(\"{|\", { beforeExpr, startsExpr }),\n  braceHashL: new TokenType(\"#{\", { beforeExpr, startsExpr }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", { beforeExpr, startsExpr }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", { beforeExpr }),\n  semi: new TokenType(\";\", { beforeExpr }),\n  colon: new TokenType(\":\", { beforeExpr }),\n  doubleColon: new TokenType(\"::\", { beforeExpr }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", { beforeExpr }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", { beforeExpr }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", { beforeExpr }),\n  backQuote: new TokenType(\"`\", { startsExpr }),\n  dollarBraceL: new TokenType(\"${\", { beforeExpr, startsExpr }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", { startsExpr }),\n\n  // Special hashbang token.\n  interpreterDirective: new TokenType(\"#!...\"),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", { beforeExpr, isAssign }),\n  assign: new TokenType(\"_=\", { beforeExpr, isAssign }),\n  incDec: new TokenType(\"++/--\", { prefix, postfix, startsExpr }),\n  bang: new TokenType(\"!\", { beforeExpr, prefix, startsExpr }),\n  tilde: new TokenType(\"~\", { beforeExpr, prefix, startsExpr }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", { beforeExpr, binop: 9, prefix, startsExpr }),\n  // startsExpr: required by v8intrinsic plugin\n  modulo: new TokenType(\"%\", { beforeExpr, binop: 10, startsExpr }),\n  // unset `beforeExpr` as it can be `function *`\n  star: new TokenType(\"*\", { binop: 10 }),\n  slash: createBinop(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true,\n  }),\n\n  // Keywords\n  // Don't forget to update packages/babel-helper-validator-identifier/src/keyword.js\n  // when new keywords are added\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", { beforeExpr }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", { beforeExpr }),\n  _do: createKeyword(\"do\", { isLoop, beforeExpr }),\n  _else: createKeyword(\"else\", { beforeExpr }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", { isLoop }),\n  _function: createKeyword(\"function\", { startsExpr }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", { beforeExpr }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", { beforeExpr, prefix, startsExpr }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", { isLoop }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", { beforeExpr, startsExpr }),\n  _this: createKeyword(\"this\", { startsExpr }),\n  _super: createKeyword(\"super\", { startsExpr }),\n  _class: createKeyword(\"class\", { startsExpr }),\n  _extends: createKeyword(\"extends\", { beforeExpr }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", { startsExpr }),\n  _null: createKeyword(\"null\", { startsExpr }),\n  _true: createKeyword(\"true\", { startsExpr }),\n  _false: createKeyword(\"false\", { startsExpr }),\n  _in: createKeyword(\"in\", { beforeExpr, binop: 7 }),\n  _instanceof: createKeyword(\"instanceof\", { beforeExpr, binop: 7 }),\n  _typeof: createKeyword(\"typeof\", { beforeExpr, prefix, startsExpr }),\n  _void: createKeyword(\"void\", { beforeExpr, prefix, startsExpr }),\n  _delete: createKeyword(\"delete\", { beforeExpr, prefix, startsExpr }),\n};\n","// @flow\n\n// Each scope gets a bitset that may contain these flags\n// prettier-ignore\nexport const SCOPE_OTHER        = 0b00000000,\n             SCOPE_PROGRAM      = 0b00000001,\n             SCOPE_FUNCTION     = 0b00000010,\n             SCOPE_ARROW        = 0b00000100,\n             SCOPE_SIMPLE_CATCH = 0b00001000,\n             SCOPE_SUPER        = 0b00010000,\n             SCOPE_DIRECT_SUPER = 0b00100000,\n             SCOPE_CLASS        = 0b01000000,\n             SCOPE_TS_MODULE    = 0b10000000,\n             SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\n\nexport type ScopeFlags =\n  | typeof SCOPE_OTHER\n  | typeof SCOPE_PROGRAM\n  | typeof SCOPE_FUNCTION\n  | typeof SCOPE_VAR\n  | typeof SCOPE_ARROW\n  | typeof SCOPE_SIMPLE_CATCH\n  | typeof SCOPE_SUPER\n  | typeof SCOPE_DIRECT_SUPER\n  | typeof SCOPE_CLASS;\n\n// These flags are meant to be _only_ used inside the Scope class (or subclasses).\n// prettier-ignore\nexport const BIND_KIND_VALUE           = 0b00000_0000_01,\n             BIND_KIND_TYPE            = 0b00000_0000_10,\n             // Used in checkLVal and declareName to determine the type of a binding\n             BIND_SCOPE_VAR            = 0b00000_0001_00, // Var-style binding\n             BIND_SCOPE_LEXICAL        = 0b00000_0010_00, // Let- or const-style binding\n             BIND_SCOPE_FUNCTION       = 0b00000_0100_00, // Function declaration\n             BIND_SCOPE_OUTSIDE        = 0b00000_1000_00, // Special case for function names as\n                                                   // bound inside the function\n             // Misc flags\n             BIND_FLAGS_NONE           = 0b00001_0000_00,\n             BIND_FLAGS_CLASS          = 0b00010_0000_00,\n             BIND_FLAGS_TS_ENUM        = 0b00100_0000_00,\n             BIND_FLAGS_TS_CONST_ENUM  = 0b01000_0000_00,\n             BIND_FLAGS_TS_EXPORT_ONLY = 0b10000_0000_00;\n\n// These flags are meant to be _only_ used by Scope consumers\n// prettier-ignore\n/*                              =    is value?    |    is type?    |      scope          |    misc flags    */\nexport const BIND_CLASS         = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_CLASS  ,\n             BIND_LEXICAL       = BIND_KIND_VALUE | 0              | BIND_SCOPE_LEXICAL  | 0                 ,\n             BIND_VAR           = BIND_KIND_VALUE | 0              | BIND_SCOPE_VAR      | 0                 ,\n             BIND_FUNCTION      = BIND_KIND_VALUE | 0              | BIND_SCOPE_FUNCTION | 0                 ,\n             BIND_TS_INTERFACE  = 0               | BIND_KIND_TYPE | 0                   | BIND_FLAGS_CLASS  ,\n             BIND_TS_TYPE       = 0               | BIND_KIND_TYPE | 0                   | 0                 ,\n             BIND_TS_ENUM       = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_TS_ENUM,\n             BIND_TS_AMBIENT    = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY,\n             // These bindings don't introduce anything in the scope. They are used for assignments and\n             // function expressions IDs.\n             BIND_NONE          = 0               | 0              | 0                   | BIND_FLAGS_NONE   ,\n             BIND_OUTSIDE       = BIND_KIND_VALUE | 0              | 0                   | BIND_FLAGS_NONE   ,\n\n             BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n             BIND_TS_NAMESPACE  = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY;\n\nexport type BindingTypes =\n  | typeof BIND_NONE\n  | typeof BIND_OUTSIDE\n  | typeof BIND_VAR\n  | typeof BIND_LEXICAL\n  | typeof BIND_CLASS\n  | typeof BIND_FUNCTION\n  | typeof BIND_TS_INTERFACE\n  | typeof BIND_TS_TYPE\n  | typeof BIND_TS_ENUM\n  | typeof BIND_TS_AMBIENT\n  | typeof BIND_TS_NAMESPACE;\n\n// prettier-ignore\nexport const CLASS_ELEMENT_FLAG_STATIC = 0b1_00,\n             CLASS_ELEMENT_KIND_GETTER = 0b0_10,\n             CLASS_ELEMENT_KIND_SETTER = 0b0_01,\n             CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\n\n// prettier-ignore\nexport const CLASS_ELEMENT_STATIC_GETTER   = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n             CLASS_ELEMENT_STATIC_SETTER   = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n             CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n             CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n             CLASS_ELEMENT_OTHER           = 0;\n\nexport type ClassElementTypes =\n  | typeof CLASS_ELEMENT_STATIC_GETTER\n  | typeof CLASS_ELEMENT_STATIC_SETTER\n  | typeof CLASS_ELEMENT_INSTANCE_GETTER\n  | typeof CLASS_ELEMENT_INSTANCE_SETTER\n  | typeof CLASS_ELEMENT_OTHER;\n","// @flow\n\nimport * as charCodes from \"charcodes\";\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nexport const lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nexport const lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n// https://tc39.github.io/ecma262/#sec-line-terminators\nexport function isNewLine(code: number): boolean {\n  switch (code) {\n    case charCodes.lineFeed:\n    case charCodes.carriageReturn:\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport const skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n// https://tc39.github.io/ecma262/#sec-white-space\nexport function isWhitespace(code: number): boolean {\n  switch (code) {\n    case 0x0009: // CHARACTER TA